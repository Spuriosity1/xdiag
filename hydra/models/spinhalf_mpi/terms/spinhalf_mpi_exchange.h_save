#pragma once

#include <algorithm>

#include <hydra/combinatorics/combinations.h>
#include <hydra/combinatorics/subsets.h>
#include <hydra/common.h>
#include <hydra/models/electron/electron.h>
#include <hydra/operators/bondlist.h>
#include <hydra/operators/couplings.h>
#include <hydra/utils/bitops.h>

#include <hydra/mpi/communicator.h>

namespace hydra::spinhalfterms {

std::tuple<BondList, BondList, BondList>
get_prefix_postfix_mixed_bonds(BondList const &bonds, int n_postfix_sites) {

  BondList prefix_bonds;
  BondList postfix_bonds;
  BondList mixed_bonds;
  for (auto bond : bonds) {
    auto sites = bond.sites();
    // Postfix bond
    if (std::all_of(sites.begin(), sites.end(), [&n_postfix_sites](int i) {
          return i < n_postfix_sites;
        })) {
      postfix_bonds << bond;
    }
    // Prefix bond
    else if (std::all_of(sites.begin(), sites.end(), [&n_postfix_sites](int i) {
               return i >= n_postfix_sites;
             })) {
      prefix_bonds << bond;
    }
    // Mixed bond
    else {
      mixed_bonds << bond;
    }
  }
  return {prefix_bonds, postfix_bonds, mixed_bonds};
}

bool coupling_is_zero(Bond const &bond, Couplings const &couplings) {
  std::string coupling = bond.coupling();
  return (!couplings.defined(coupling)) ||
         lila::close(couplings[coupling], (complex)0.);
}

template <class bit_t, class coeff_t>
void do_exchange_mpi(BondList const &bonds, Couplings const &couplings,
                     SpinhalfMPI<bit_t> const &block,
                     lila::Vector<coeff_t> const &vec_in,
                     lila::Vector<coeff_t> &vec_out) {
  int mpi_rank, mpi_size;
  MPI_Comm_rank(MPI_COMM_WORLD, &mpi_rank);
  MPI_Comm_size(MPI_COMM_WORLD, &mpi_size);

  auto exchange_bonds = bonds.bonds_of_type("HEISENBERG") +
                        bonds.bonds_of_type("EXCHANGE") +
                        bonds.bonds_of_type("HB");

  int n_prefix_bits = block.n_prefix_bits_;
  int n_postfix_bits = block.n_postfix_bits_;
  auto [prefix_bonds, postfix_bonds, mixed_bonds] =
      get_prefix_postfix_mixed_bonds(exchange_bonds, n_postfix_bits);

  /////////////////////////////////////////////////
  // Apply postfix bonds, no communication required
  for (auto bond : postfix_bonds) {
    if (coupling_is_zero(bond, couplings))
      continue;
    if (bond.size() != 2)
      LogMPI.err("Error computing SpinhalfMPI Exchange: "
                 "bond must have exactly two sites defined");
    coeff_t Jhalf = lila::real(couplings[bond.coupling()]) / 2.;
    int s1 = bond.site(0);
    int s2 = bond.site(1);
    if (s1 == s2)
      LogMPI.err("Error computing SpinhalfMPI Exchange: "
                 "operator acting on twice the same site");
    bit_t mask = ((bit_t)1 << s1) | ((bit_t)1 << s2);

    // loop through all postfixes
    idx_t idx = 0;
    idx_t idx_prefix = 0;
    for (auto prefix : block.prefixes_) {
      int n_up_prefix = utils::popcnt(prefix);
      int n_up_postfix = block.n_up() - n_up_prefix;
      LinTable<bit_t> const &lintable = block.postfix_lintables_[n_up_postfix];
      for (auto postfix : Combinations<bit_t>(n_postfix_bits, n_up_postfix)) {

        if (utils::popcnt(postfix & mask) & 1) {
          bit_t new_postfix = postfix ^ mask;
          idx_t new_idx = idx_prefix + lintable.index(new_postfix);
          vec_out(new_idx) += Jhalf * vec_in(idx);
        }
        ++idx;
      }
      idx_prefix += combinatorics::binomial(n_postfix_bits, n_up_postfix);
      assert(idx_prefix == idx);
    }
  }

  /////////////////////////////////////////////////
  // Transpose, apply prefix bonds, transpose

  // determine how many states I send
  std::vector<idx_t> n_states_i_send(mpi_size, 0);
  for (auto prefix : block.prefixes_) {
    int n_up_prefix = utils::popcnt(prefix);
    int n_up_postfix = block.n_up() - n_up_prefix;
    for (auto postfix : Combinations<bit_t>(n_postfix_bits, n_up_postfix)) {
      int target_proc = block.process(postfix);
      ++n_states_i_send[target_proc];
    }
  }

  // Set up buffers for communicating
  mpi::Communicator com(n_states_i_send);
  idx_t buffer_size = std::max(com.send_buffer_size(), com.recv_buffer_size());
  std::vector<coeff_t> send_buffer(buffer_size, 0);
  std::vector<coeff_t> recv_buffer(buffer_size, 0);
  auto send_offsets = com.n_values_i_send_offsets();
  auto recv_offsets = com.n_values_i_recv_offsets();

  int n_sites = 6;

  // Fill send buffer
  com.flush();

  std::vector<bit_t> send_states(com.send_buffer_size(),
                                 0); // Only for Debug purpuses
  std::vector<bit_t> n_send_states_prepared(mpi_size,
                                            0); // Only for Debug purpuses
  idx_t idx = 0;
  for (auto prefix : block.prefixes_) {
    int n_up_prefix = utils::popcnt(prefix);
    int n_up_postfix = block.n_up() - n_up_prefix;
    for (auto postfix : Combinations<bit_t>(n_postfix_bits, n_up_postfix)) {
      int target_rank = block.process(postfix);

      ////////////////////////////////////////////////////////////////////
      printf("%s %s [%d] -> [%d] %f\n",
             bits_to_string(prefix, n_sites / 2).c_str(),
             bits_to_string(postfix, n_sites / 2).c_str(), mpi_rank,
             target_rank, vec_in(idx));
      ////////////////////////////////////////////////////////////////////

      com.add_to_send_buffer(target_rank, vec_in(idx), send_buffer);

      ////////////////////////////////////////////////////////////////////
      send_states[send_offsets[target_rank] +
                  n_send_states_prepared[target_rank]] =
          (prefix << n_postfix_bits | postfix); // Debug
      ++n_send_states_prepared[target_rank];    // Debig
      ////////////////////////////////////////////////////////////////////


      ++idx;
    }
  }

  MPI_Barrier(MPI_COMM_WORLD);

  ////////////////////////////////////////////////////////////////////
  // Fat DEBUG Print
  if (mpi_rank == 0)
    printf("SEND BUFFER before sending --------------------------------\n");
  MPI_Barrier(MPI_COMM_WORLD);
  for (int nt = 0; nt < mpi_size; ++nt) {
    if (mpi_rank == nt) {
      printf("[%d]:\n", mpi_rank);

      for (int sendto = 0; sendto < mpi_size; ++sendto) {
        int from = send_offsets[sendto];
        int to = (sendto == mpi_size - 1) ? com.send_buffer_size()
                                          : send_offsets[sendto + 1];
        for (int idx = from; idx < to; ++idx)
          printf("%s %s [%d] -> [%d] %f \n",
                 bits_to_string(send_states[idx] >> n_postfix_bits, n_sites / 2)
                     .c_str(),
                 bits_to_string(send_states[idx] & ((1 << n_postfix_bits) - 1),
                                n_sites / 2)
                     .c_str(),
                 mpi_rank, sendto, send_buffer[idx]);
      }
      printf("\n");
    }
    MPI_Barrier(MPI_COMM_WORLD);
  }
  MPI_Barrier(MPI_COMM_WORLD);
  ////////////////////////////////////////////////////////////////////


  // Communicate
  com.all_to_all(send_buffer, recv_buffer);


  ////////////////////////////////////////////////////////////////////
  /// DEBUG create vector of recv states
  std::vector<bit_t> states_recv(com.recv_buffer_size());
  {
    std::vector<idx_t> offsets(mpi_size, 0);

    for (auto prefix : Subsets<bit_t>(n_prefix_bits)) {
      int n_up_prefix = utils::popcnt(prefix);
      int n_up_postfix = block.n_up() - n_up_prefix;
      if ((n_up_postfix < 0) || (n_up_postfix > n_postfix_bits))
        continue;

      int origin_rank = block.process(prefix);
      idx_t origin_offset = recv_offsets[origin_rank];

      for (auto postfix : block.postfixes_) {
        if (utils::popcnt(postfix) != n_up_postfix)
          continue;

        idx_t idx = origin_offset + offsets[origin_rank];
        bit_t state = (prefix << n_postfix_bits | postfix);

        // printf("%s %s [%d] <- [%d] %d + %d  = %ld \n",
        //        bits_to_string(prefix, n_sites / 2).c_str(),
        //        bits_to_string(postfix, n_sites / 2).c_str(), mpi_rank,
        //        origin_rank, origin_offset, offsets[origin_rank], idx);

        states_recv[idx] = state;

        ++offsets[origin_rank];
      }
    }
  }
  /////////////////////////////////////////////////////////////////////



  /////////////////////////////////////////////////////////////////////
  // Fat DEBUG Print
  if (mpi_rank == 0)
    printf("RECV BUFFER after sending --------------------------------\n");
  MPI_Barrier(MPI_COMM_WORLD);
  for (int nt = 0; nt < mpi_size; ++nt) {
    if (mpi_rank == nt) {
      printf("[%d]:\n", mpi_rank);

      // for (int i = 0; i < states_recv.size(); ++i) {
      //   printf("%s\n", bits_to_string(states_recv[i], n_sites).c_str());
      // }

      for (int recvfrom = 0; recvfrom < mpi_size; ++recvfrom) {
        int from = recv_offsets[recvfrom];
        int to = (recvfrom == mpi_size - 1) ? com.recv_buffer_size()
                                            : recv_offsets[recvfrom + 1];
        for (int idx = from; idx < to; ++idx)
          printf("%s %s [%d] <- [%d] %f \n",
                 bits_to_string(states_recv[idx] >> n_postfix_bits, n_sites / 2)
                     .c_str(),
                 bits_to_string(states_recv[idx] & ((1 << n_postfix_bits) - 1),
                                n_sites / 2)
                     .c_str(),
                 mpi_rank, recvfrom, recv_buffer[idx]);
      }
      printf("\n");
    }
    MPI_Barrier(MPI_COMM_WORLD);
  }
  MPI_Barrier(MPI_COMM_WORLD);
  /////////////////////////////////////////////////////////////////////


  std::vector<idx_t> offsets(mpi_size, 0);
  for (auto prefix : Subsets<bit_t>(n_prefix_bits)) {
    int n_up_prefix = utils::popcnt(prefix);
    int n_up_postfix = block.n_up() - n_up_prefix;
    if ((n_up_postfix < 0) || (n_up_postfix > n_postfix_bits))
      continue;

    int origin_rank = block.process(prefix);
    idx_t origin_offset = recv_offsets[origin_rank];

    idx_t prefix_idx = block.prefix_lintables_[n_up_prefix].index(prefix);
    for (auto postfix : block.postfixes_) {
      if (utils::popcnt(postfix) != n_up_postfix)
        continue;

      idx_t idx_received = origin_offset + offsets[origin_rank];
      idx_t idx_sorted = block.postfix_limits_.at(postfix).first + prefix_idx;

      send_buffer[idx_sorted] = recv_buffer[idx_received];

      // printf("sort [%d] r: %d s %d %f \n", mpi_rank, idx_received, idx_sorted,
      //        recv_buffer[idx_received]);

      ++offsets[origin_rank];
    }
  }

  // Fat DEBUG Print
  if (mpi_rank == 0)
    printf("SEND BUFFER after sorting --------------------------------\n");
  MPI_Barrier(MPI_COMM_WORLD);
  for (int nt = 0; nt < mpi_size; ++nt) {
    if (mpi_rank == nt) {
      printf("[%d]:\n", mpi_rank);

      // loop through all prefixes
      idx_t idx = 0;
      idx_t idx_prefix = 0;
      for (auto postfix : block.postfixes_) {
        int n_up_postfix = utils::popcnt(postfix);
        int n_up_prefix = block.n_up() - n_up_postfix;
        LinTable<bit_t> const &lintable = block.prefix_lintables_[n_up_prefix];
        for (auto prefix : Combinations<bit_t>(n_prefix_bits, n_up_prefix)) {
          printf("%s %s %f \n", bits_to_string(prefix, n_sites / 2).c_str(),
                 bits_to_string(postfix, n_sites / 2).c_str(),
                 send_buffer[idx]);
          ++idx;
        }
        idx_prefix += combinatorics::binomial(n_postfix_bits, n_up_postfix);
        assert(idx_prefix == idx);
      }

      printf("\n");
    }
    MPI_Barrier(MPI_COMM_WORLD);
  }
  MPI_Barrier(MPI_COMM_WORLD);

  MPI_Abort(MPI_COMM_WORLD, 1);
}

} // namespace hydra::spinhalfterms
